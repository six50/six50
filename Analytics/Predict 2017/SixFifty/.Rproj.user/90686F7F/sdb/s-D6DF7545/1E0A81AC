{
    "collab_server" : "",
    "contents" : "# Swingometer\n#\n# Currently this is just an R script but may be transitioned to a R Package if the size of the work\n# requires it. Currently does a rudimentary analysis of the data\n\nlibrary(data.table)\nlibrary(ggplot2)\nlibrary(GGally)\n\n# Import the data\nge.results <- list(\"2015\" = fread(\"../../2015-UK-general-election-data-results-WEB/RESULTS FOR ANALYSIS.csv\"),\n                   \"2010\" = fread(\"../../GE2010-results-flatfile-website.csv\"))\nref.results <- fread(\"../../EU-referendum-result-data.csv\")\nconst.info <- fread(\"../../2015-UK-general-election-data-results-WEB/CONSTITUENCY.csv\")\n\n# Some quick cleaning tools\nstringToInt <- function(number) {\n  as.numeric(gsub(number, pattern = \",\", replacement = \"\"))\n}\n\n# Convert string to int\nto.convert <- c(\"Electorate\", \"Total number of valid votes counted\")\nge.results$`2015`[, (to.convert) := lapply(.SD, stringToInt), .SDcols = to.convert]\n\n# Set all NA values to zero as required\nremove.na <- function (x) {\n  missing.vals <- is.na(x)\n  if(any(missing.vals)) x[missing.vals] <- 0\n  x\n}\nremoveNAValues <- function(voting.data) {\n  integer.fields <- names(which(sapply(voting.data, is.integer)))\n  voting.data[, (integer.fields) := lapply(.SD, remove.na), .SDcols = integer.fields]\n}\n\nge.results <- lapply(ge.results, removeNAValues)\n\n# Function to clean EU ref results data\ngetEUResultsByRegion <- function(eu.data) {\n  # Gen numeric columns and set the type accordingly\n  numeric.cols <- names(eu.data)[-c(2:5)]\n  eu.data <- eu.data[, (numeric.cols) := lapply(.SD, as.numeric), .SDcols = numeric.cols]\n\n  # Get EU result by region\n  eu.by.region <- split(eu.data, eu.data$Region)\n  eu.by.region <- lapply(eu.by.region,\n                         function (x) {c(Remain = sum(x$Remain),\n                                         Leave = sum(x$Leave),\n                                         Total = sum(x$Valid_Votes))})\n\n  # Calculate the percentage remain by region\n  pc.remain <- sapply(eu.by.region, function(x) x[\"Remain\"]/x[\"Total\"])\n  names(pc.remain) <- names(eu.by.region)\n\n  pc.remain\n}\n\npc.remain <- getEUResultsByRegion(ref.results)\n\n# Ad the remain result to the table\nge.results <- lapply(ge.results, function(x) x[, Vote_Remain_Pct := pc.remain[x$Region]])\nsetnames(ge.results$`2010`, \"Con\", \"C\")\nsetnames(ge.results$`2015`, \"Total number of valid votes counted\", \"Votes\")\n\ngetSwing <- function(elec.data, key.party.cols =  c(\"LD\", \"C\", \"Lab\"), test.polling.numbers = c(0.10, 0.44, 0.26)) {\n\n  # Get the percentage of votes by party\n  pc.v.names <- paste0(key.party.cols, \"_PC_Vote\")\n  getPercentage <- function(x) {x/elec.data$Votes}\n\n  # Update the table accodingly\n  elec.data[, (pc.v.names) := lapply(.SD, getPercentage), .SDcols = key.party.cols]\n  elec.data[, OTHER_PC_VOTE :=  1 - apply(elec.data[, pc.v.names, with = F],1,sum, na.rm = T)]\n\n  # Update meta\n  key.party.cols <- c(key.party.cols, \"OTHER\")\n  pc.v.names <- c(pc.v.names, \"OTHER_PC_VOTE\")\n\n  # Calculate the distance each constituency is from the mean\n  dis.mean <- paste0(key.party.cols, \"_DIFF_MEAN\")\n  getDistanceFromMean <- function(x) {x - mean(x, na.rm = T)}\n  elec.data[, (dis.mean) := lapply(.SD, getDistanceFromMean), .SDcols = pc.v.names]\n\n  # Test polling numbers\n  test.polling.numbers <- c(test.polling.numbers, 1 - sum(test.polling.numbers))\n  names(test.polling.numbers) <- key.party.cols\n\n  # Function which gets the winner (based on index)\n  getWinner <- function(dist.figs, polling.nums) {\n    key.party.cols[which.max(polling.nums + as.vector(dist.figs))]\n  }\n\n  getPercentage <- function(dist.figs, polling.nums) {\n    polling.nums + as.vector(dist.figs)\n  }\n\n  # Calculate the percentages by constituency\n  percentages <- t(apply(elec.data[,dis.mean, with = F], 1,\n                         getPercentage, polling.nums = test.polling.numbers))\n\n  # Get the predictions\n  predictions <- data.table(constituency = elec.data$`Constituency Name`,\n                            winner = factor(apply(elec.data[,dis.mean, with = F], 1,\n                                                  getWinner, polling.nums = test.polling.numbers)),\n                            LD_RESULT = percentages[,\"LD\"], C_RESULT = percentages[,\"C\"],\n                            Lab_RESULT = percentages[,\"Lab\"], OTHER_RESULT = percentages[,\"OTHER\"])\n\n}\n\npredictions <- lapply(ge.results, getSwing)\n\n#\n# # Get the percentage of votes by party\n# key.party.cols <- c(\"LD\", \"C\", \"Lab\")\n# pc.v.names <- paste0(key.party.cols, \"_PC_Vote\")\n# getPercentage <- function(x) {x/ge.results.2015$`Total number of valid votes counted`}\n#\n# # Update the table accodingly\n# ge.results.2015[, (pc.v.names) := lapply(.SD, getPercentage), .SDcols = key.party.cols]\n# ge.results.2015[, OTHER_PC_VOTE :=  1 - apply(ge.results.2015[, pc.v.names, with = F],1,sum, na.rm = T)]\n#\n# # Update meta\n# key.party.cols <- c(key.party.cols, \"OTHER\")\n# pc.v.names <- c(pc.v.names, \"OTHER_PC_VOTE\")\n#\n# # Calculate the distance each constituency is from the mean\n# dis.mean <- paste0(key.party.cols, \"_DIFF_MEAN\")\n# getDistanceFromMean <- function(x) {x - mean(x, na.rm = T)}\n# ge.results.2015[, (dis.mean) := lapply(.SD, getDistanceFromMean), .SDcols = pc.v.names]\n#\n# # Test polling numbers (as of 20th of April 2010)\n# test.polling.numbers <- c(0.10, 0.44, 0.26)\n# test.polling.numbers <- c(test.polling.numbers, 1 - sum(test.polling.numbers))\n# names(test.polling.numbers) <- key.party.cols\n#\n# # Function which gets the winner (based on index)\n# getWinner <- function(dist.figs, polling.nums) {\n#   key.party.cols[which.max(polling.nums + as.vector(dist.figs))]\n# }\n#\n# getPercentage <- function(dist.figs, polling.nums) {\n#   polling.nums + as.vector(dist.figs)\n# }\n#\n# # Calculate the percentages by constituency\n# percentages <- t(apply(ge.results.2015[,dis.mean, with = F], 1,\n#                      getPercentage, polling.nums = test.polling.numbers))\n#\n# # Get the predictions\n# predictions <- data.table(constituency = ge.results.2015$`Constituency Name`,\n#                           winner = factor(apply(ge.results.2015[,dis.mean, with = F], 1,\n#                                                                getWinner, polling.nums = test.polling.numbers)),\n#                           LD_RESULT = percentages[,\"LD\"], C_RESULT = percentages[,\"C\"],\n#                           Lab_RESULT = percentages[,\"Lab\"], OTHER_RESULT = percentages[,\"OTHER\"])\n\n# Create a quick plot\nggpairs(ge.results$`2015`[, c(\"Vote_Remain_Pct\", pc.v.names), with = F])\nggpairs(ge.results$`2010`[, c(\"Vote_Remain_Pct\", pc.v.names), with = F])\n\n\n# Write the prediction to csv\nwrite.csv(x = predictions$`2015`,file =  \"../../predictions_2015.csv\", row.names =F)\nwrite.csv(x = predictions$`2015`,file =  \"../../predictions_2010.csv\", row.names =F)\n",
    "created" : 1492595366394.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3736925905",
    "id" : "1E0A81AC",
    "lastKnownWriteTime" : 1493053428,
    "last_content_update" : 1493053428354,
    "path" : "~/Documents/Political Data/Predict 2017/SixFifty/R/Swingometer.R",
    "project_path" : "R/Swingometer.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}